---
title: "It's if_else statements all the way down..."
author: matt_gregory
comments: yes
date: '2017-02-23'
modified: 2017-02-24
layout: post
excerpt: "How to vectorise multiple if and else if statements"
published: FALSE
status: processed
tags:
- case when
categories: Rstats
output: html_document
---
 

 
I've been [developing](http://r-pkgs.had.co.nz/) a [package](https://github.com/mammykins) where I needed a function to take numerous different actions (different [mutations]()) depending on the values of different variables within each row of a dataframe. I started off by using a series of nested `dplyr::if_else` functions inside of a `dplyr::mutate` call. I ended up with a bit of a mess, perhaps a dozen or so `if_else` calls... that's when I got some abuse from my colleague following a Github pull request.
 
### Vector example
 

{% highlight r %}
library(tidyverse)
 
x <- 1:50  #  a numeric vector from one to fifty
  
if_else(x %% 35 == 0, "fizz buzz", #  divisible by 35 with no remainder
        if_else(x %% 5 == 0, "fizz",
                if_else(x %% 7 == 0, "buzz",
                        "flat"
                        )
                )
        ) %>%
  table(dnn = "fizzybuzzyness") %>%  #  give the vector of character strings a nice name
  as_tibble(x = ., n = "how_many") %>%  #  give the frequency a nice name
  ggplot(., aes(fizzybuzzyness, how_many)) +  #  the . means "the output piped from the previous step"
  geom_bar(stat = "identity") +  #  strings are sorted "alphabetically"
  govstyle::theme_gov() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
{% endhighlight %}

![plot of chunk 2017-02-23-barplot-fizz_if_else](/C:/Users/mammykins/Documents/GitHub/machinegurning.github.io/figures2017-02-23-barplot-fizz_if_else-1.svg)
 
There must be a better way? A quick Google got me [here](https://edwinth.github.io/blog/ifelse-wrapper/). A neat idea, but I noticed the suggestion of the new-ish `dplyr::case_when` function in the comments section of this excellent blog post. I've taken up the baton, by exploring this function in this post.  
 
The example from the `?case_when` is quite informative; I give a visual interpretation (see the code comments for details). However, we should explore it further and apply it to a dataframe to expand our understanding.
 

{% highlight r %}
# ?case_when
 
x <- 1:50  #  a numeric vector from one to fifty
 
case_when(
  x %% 35 == 0 ~ "fizz buzz",  #  if divisible by 35 make "fizz buzz" else
  x %% 5 == 0 ~ "fizz",  #  if divisible by 5 make "fizz", unless already "fizz buzz" else
  x %% 7 == 0 ~ "buzz",  #  if divisible by 7 make "buzz" unless already "fizz buzz" or "fizz"
  TRUE ~ "flat"  #  anything else convert into flat
) %>%
  table(dnn = "fizzybuzzyness") %>%  #  give the vector of character strings a nice name
  as_tibble(x = ., n = "how_many") %>%  #  give the frequency a nice name, default is n
  ggplot(., aes(fizzybuzzyness, how_many)) +  #  the . means "the output piped from the previous step"
  geom_bar(stat = "identity") +  
  govstyle::theme_gov() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
{% endhighlight %}

![plot of chunk 2017-02-23-barplot-fizz_case_when](/C:/Users/mammykins/Documents/GitHub/machinegurning.github.io/figures2017-02-23-barplot-fizz_case_when-1.svg)
 
The same outcome but which did you find the more readable? (Imagine you were quality assuring this code?)  
 
### Dataframes example
 
As pointed out in the `case_when` help examples, ordering is important where you want to go from most specific to least specific. In the example below we wanted the `Mazda RX4 Wag` to be labbelled as a `Mazda Wagon` in the newly created `brand` variable. This failed due to our ordering; to suceed we should move this before the left hand side (LHS) first argument. Notice how the right hand side of the `~` provides the replacement value. Try replacing the `"Wow"` with a numeric 50, what happens when you run the code?
 

{% highlight r %}
mtcars %>%
  tibble::rownames_to_column("thecar") %>%  #  convert row names to an explicit column
  mutate(brand = case_when(.$thecar == "Mazda RX4" | .$thecar == "Mazda RX4 Wag"  ~ "Mazda",  #  You should start with the most specific...
                           .$thecar == "Mazda RX4 Wag" ~ "Mazda Wagon",  #  Otherwise this happens; note how ordering is important!
                           .$thecar == "Maserati Bora" & .$hp > 300 ~ "Wow!",  #  and / or, logical tests
                            TRUE ~ "Not Mazda")  #  everything else
          ) %>%
  select(brand) %>%
  table()
{% endhighlight %}



{% highlight text %}
## .
##     Mazda Not Mazda      Wow! 
##         2        29         1
{% endhighlight %}
 
`case_when` is still [somewhat new and experimental](https://blog.rstudio.org/2016/06/27/dplyr-0-5-0/). For now I may stick with nested `if_else` statements until this is more stable and works well within mutate despite `case_when` being a bit easier to read. If you play around with this demo code it's quite easy to break, this may be in part to some useful non-standard evaluation intrinsic to `mutate`. For example replacing the `&` with `&&` causes it to error. Try it with your own data and keep your eyes peeled for further developments! In [Hadley](https://github.com/hadley) we trust.
 
## Conclusion
 
A relatively new offering from the `tidyverse` on making nested `if_else` statements more readible.  
 

{% highlight r %}
devtools::session_info()
{% endhighlight %}



{% highlight text %}
##  setting  value                       
##  version  R version 3.3.2 (2016-10-31)
##  system   x86_64, mingw32             
##  ui       RStudio (1.0.136)           
##  language (EN)                        
##  collate  English_United Kingdom.1252 
##  tz       Europe/London               
##  date     2017-02-24                  
## 
##  package      * version date      
##  assertthat     0.1     2013-12-06
##  car            2.1-3   2016-08-11
##  caret        * 6.0-72  2016-11-01
##  checkpoint     0.3.18  2016-10-31
##  chron          2.3-47  2015-06-24
##  codetools      0.2-15  2016-10-05
##  colorspace     1.2-7   2016-10-11
##  data.table     1.9.6   2015-09-19
##  DBI            0.5-1   2016-09-10
##  devtools       1.12.0  2016-06-24
##  digest         0.6.11  2017-01-03
##  dplyr        * 0.5.0   2016-06-24
##  evaluate       0.10    2016-10-11
##  foreach        1.4.3   2015-10-13
##  GGally       * 1.2.0   2016-07-01
##  ggplot2      * 2.1.0   2016-03-01
##  ggthemes     * 3.2.0   2016-07-11
##  govstyle       0.1.0   2016-11-14
##  gtable         0.2.0   2016-02-26
##  highr          0.6     2016-05-09
##  iterators      1.0.8   2015-10-13
##  knitr          1.15.1  2016-11-22
##  labeling       0.3     2014-08-23
##  lattice      * 0.20-34 2016-09-06
##  lazyeval       0.2.0   2016-06-12
##  lme4           1.1-12  2016-04-16
##  magrittr       1.5     2014-11-22
##  MASS           7.3-45  2016-04-21
##  Matrix         1.2-7.1 2016-09-01
##  MatrixModels   0.4-1   2015-08-22
##  memoise        1.0.0   2016-01-29
##  mgcv           1.8-15  2016-09-14
##  minqa          1.2.4   2014-10-09
##  ModelMetrics   1.1.0   2016-08-26
##  munsell        0.4.3   2016-02-13
##  nlme           3.1-128 2016-05-10
##  nloptr         1.0.4   2014-08-04
##  nnet           7.3-12  2016-02-02
##  pbkrtest       0.4-6   2016-01-27
##  plyr           1.8.4   2016-06-08
##  purrr        * 0.2.2   2016-06-18
##  quantreg       5.29    2016-09-04
##  R6             2.2.0   2016-10-05
##  Rcpp           0.12.7  2016-09-05
##  readr        * 1.0.0   2016-08-03
##  reshape        0.8.6   2016-10-21
##  reshape2       1.4.2   2016-10-22
##  rmd2md         0.1.4   2017-01-16
##  scales         0.4.0   2016-02-26
##  SparseM        1.72    2016-09-06
##  stringi        1.1.2   2016-10-01
##  stringr        1.1.0   2016-08-19
##  tibble       * 1.2     2016-08-26
##  tidyr        * 0.6.0   2016-08-12
##  tidyverse    * 1.0.0   2016-09-09
##  withr          1.0.2   2016-06-20
##  xgboost      * 0.6-3   2016-12-31
##  source                                      
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  Github (UKGov-Data-Science/govstyle@57809d1)
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  Github (ivyleavedtoadflax/rmd2md@e2d6ae4)   
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.1)                              
##  CRAN (R 3.3.2)
{% endhighlight %}
