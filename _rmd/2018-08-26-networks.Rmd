---
title: "The century of complexity"
author: matt_gregory
comments: yes
date: '2018-08-26'
modified: `r format(Sys.time(), '%Y-%m-%d')`
layout: post
excerpt: "How can network science help?"
published: FALSE
status: process
tags:
 - Networks
 - Network
 - Graph
 - Algorithm
categories: Rstats
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  dev = "svg",
  include = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE,
  cache = TRUE
  )
```

The universe is hopelessly complicated. Within it are systems that make the mind boggle. Think of the number of interconnected neurons in your brain required to understand this sentence ( [connectome](http://www.humanconnectomeproject.org/)); and the [network of interactions](https://en.wikipedia.org/wiki/Gene_regulatory_network) between genes, proteins and metabolites required to make the [cellular network](https://www.humancellatlas.org/) that is prereqisite to life.  

> “I think the next century will be the century of complexity.” - Stephen Hawking  

All is not lost. These seemingly intractably complicated problems can and have been succesffully modelled. This is particulalry apparent in some of the most succesful companies that have leveraged network science for profit. This also emphasises the empirical and data driven nature of network science.   

In addition to the conspicuous applied succeses of network science (e.g. see [Facebook's value](https://www.forbes.com/companies/facebook/)). A key discovery of network science is that the architecture of networks emerging in various domains of science, nature, and technology are similar to each other, a consequence of being governed by the same organizing principles. Consequently we can use a common set of mathematical tools to explore these systems.  

We use R as it has a bunch of [awesome packages for network analysis](https://github.com/qinwf/awesome-R#network-analysis). We also consider how you might deploy a visualisation of your network online.  

The objectives of this post are to:  

* use a simple example to teach you the fundamental units and language of network science.  
* provide links to other resources for more code examples.  
* convert a real world business example into a graph data base using Docekr and Neo4j.  
* provide some interactive visualisation options that scale.    

## Your first network

This is probably not your first run-in with network science. Did you ever draw a food web at school? Let's use R to recreate and relive that joy of sketching a simple food web. We'll use this to understand the fundamentals of networks that will scaffold our understanding to visualising and analysing a more complicated real world business data set. This will allow you to spot the opportunity for using graphs and network science to solve a range of problems in your organisation.    

## Graph fundamentals

Soil science isn't widely regarded as being sexy but my [co-blogger](https://dspace.lib.cranfield.ac.uk/handle/1826/9298) might disagree with this assertion. To help promote this important discipline we use it is our basis for a food web and a model complex system (which we greatly simplify).    

A food web is an extension of the concept of a food chain which allows for a more detailed description of how species depend on each other. A food web can be modelled via a graph in which the nodes (or vertices) represent the species and the edges (links or relationships) represent feeding connections; an edge from node A to node B indicates species B consumes species A. Note how there is a direction to the edge; FROM one node TO another, thus we say it is a "directed" graph. We use the `igraph::graph_from_literal` function as it is useful if you want to create a small (named) graph quickly, it works for both directed and undirected graphs.  

From `?` we read that we must supply one or more R expressions giving the structure of the graph. The expressions consist of vertex names and edge operators. An edge operator is a sequence of ‘-’ and ‘+’ characters, the former is for the edges and the latter is used for arrow heads. The edges can be arbitrarily long, i.e. you may use as many ‘-’ characters to “draw” them as you like (this [tutorial](http://kateto.net/ruworkshop#21_create_networks) provides greater depth and exploration of `igraph` network creation functions).

```{r}
library(igraph)

# build the graph
soil_web <- graph_from_literal(A -+ B)
soil_web
```

The first line always starts with IGRAPH, showing you that the object is an `igraph graph`. For interpreting the rest of the output see the [relevant help](http://igraph.org/r/doc/print.igraph.html) of the `igraph` manual. What does the "D" mean?    

We also have easy access to nodes, edges with:

```{r}
E(soil_web)       # The edges of the "soil_web" object

V(soil_web)       # The vertices of the "soil_web" object

```

## Simple visualisation

More generally, if we want to understand a complex system, we need to know how its components interact with each other in a more human-readable format. In other words we need a map of its wiring diagram.   

```{r 2018-08-26-soil_web, fig.height=3, fig.width=3}
# make visualisation reproducible
set.seed(255)
# visualise it
plot(soil_web)
```

There are [many approaches](http://kateto.net/ruworkshop#4_plotting_network_data) you can use to prettify and customise your visualisation within R. You can even create interactive plots for this. In this blog post we focus on alternative software that has the graph database Neo4J as its core, but first we think about how we represent this data. How do we go about capturing this data in the first place?    

## Representing graphs

Representing data as a graph is very generaliseable and may be better suited to a problem than traditional relational databases, depending on the type of questions your users are interested in asking.  

Let's increase the complexity of our soil food web by adding an extra species and including scavenging relationships as well as predation.  

```{r 2018-08-26-soil_web2, fig.height=3, fig.width=3}
# build the more complicated directed graph or digraph
soil_web2 <- graph_from_literal(A -+ B, B -+ C,
                                C -+ B, C -+ A)

# visualise it
# A eats B, B scavenges on C, C scavenges on B, C eats A
plot(soil_web2)
```

We now consider how we might represent this data mathematically.  

### Adjacency matrix

A very common way to define graphs is via a two dimensional array known as an adjacency [matrix](http://networksciencebook.com/chapter/2#matrix). Continuing from the example above, how would we represent this graph as a matrix?  

We'll break this down into simple steps, first we create an empty [square matrix](https://en.wikipedia.org/wiki/Square_matrix) correpsonding to the number of species in our food web (or nodes in our graph).  

```{r}
# create an empty matrix to hold our relationships
m <- matrix(data = 0,
            nrow = 3, ncol = 3,
            dimnames = list(
              # row names, i
              c("A", "B", "C"),
              # col names, j
              c("A", "B", "C")
              )
            )

m
```

Thus we have three species all unconnected. Let's add our connections from our "complicated" food web. As we have named our dimensions, we can use these to assign a value to the relationship, or we can use regular matrix indexing by supplying a 1d index for each dimension, separated by a comma.  

```{r}
# from A to B, or A eats B
m["A", "B"] <- 1
m
```
Species B scavenges on species C:

```{r}
# from B to C
m[2, 3] <- 1
m
```

And the last two relationships where C eats A and C scavenges B (here we mix methods as experimentation helps us learn, try it out yourself):  

```{r}
# from C to A and from C to B
m[c("C", "C"), c(1, 2)] <- 1
m
```

When reading these matrices remember that the rows tell you FROM and the columns TO. So FROM A to B should draw an arrow in your mind from node A to B, thus A eats B.  

This format is machine readable but not particularly human readable. For most graphs it will also be a spare matrix, with mostly zeroes, as most nodes will be unconnected. We introduce the adjacency matrix here as it's quite straight forward and many network packages in R use the adjacency matrix to create specific classes for the appropriate packages (see this [blog by Jesse Saddler](https://www.jessesadler.com/post/network-analysis-with-r/) for some examples).

Note one weakness of this approach, our edges are not labelled. We fail to distinguish between whether the relationship is predation or scavenging. Thus we could improve things by using a graph database that stores these additional characteristics of the relationship.  

Another problem is that human's who capture this data in the first instance (typically in a spreadsheet) are unlikely to have the data in this format. We discuss different representational formats later.  

### Useful statistics

There's a bunch of useful characteristics of our graph that we can calculate using standard approaches described [here](http://networksciencebook.com/chapter/2#degree). These help us ask questions about the [connectedness of a graph](http://networksciencebook.com/chapter/2#connectedness), [distances between nodes](http://networksciencebook.com/chapter/2#paths) and the the degree to which the neighbors of a given node link to each other ( [clustering](http://networksciencebook.com/chapter/2#clustering)).  

```{r}
# the number of a nodes adjacent edges
# how many links does it have?
# this could help us identify keystone species
degree(soil_web2)
```

Given the above toy example we'll use a real world data set later in this post to explore graph statistics and useful algorithms for solving problems.  

## Spreadsheet friendly representation?

Most organisations are stuck collecting and manipulating data in spreadsheets. Can we represent our network in one spreadsheet?  

Those of you familiar with the `tidyverse` and the concept of the [tidy data set](http://vita.had.co.nz/papers/tidy-data.html) will . Tidy datasets are easy to manipulate, model and visualize, and have a specific structure: each variable is a column, each observation is a row, and each type of observational unit is a table.

We could just use one spreadsheet to capture the above information that is also arguably a bit easier for a human to interpret (and enter data for). All we need is information of which edge goes where (importantly each node must have a unique identifier). We call this information an edge list, where we need to know what node an edge goes FROM and TO. We'll draw an edge list for our example above.  

```{r}
library(tidyverse)
# Where Species A is id 1, Species B id 2, Species C id 3
edge_list <- tibble(from = c(1, 2, 3, 3), to = c(2, 3, 1, 2))

edge_list

```

A quick sense check; does this have the same number of edges as our adjacency matrix?  

```{r}
if (nrow(edge_list) == sum(m)) {
  print("The number of edges in the edge list equals the sum of ones in the adjacency matrix!")
}
```


Is this sufficient? What might we be missing? Earlier we mentioned how our relationships or edges were directed. We get this information by the FROM and TO but we can enhance it by providing a description of the type of relationship.  

```{r}
# Where Species A is id 1, Species B id 2, Species C id 3
edge_list <- edge_list %>%
  # describe the type of interaction
  # we use CAPS as it's the convention for Neo4j, a popular graph database
  mutate(description = c("PREDATES", "SCAVENGES", "SCAVENGES", "PREDATES"))

edge_list
```

If we included a seperate node list we could have an attributes column that helps us describe the characteristics of each species, that could be useful or provide further insight for our interpretation. For example, every product is now being classified as gluten free, thus we might like to add this extra information into our food web so that our discerning species can decide on an appropriate food source.  

This can be very handy for spotting patterns and later analysis, so ensure you use an informative description that will meet your analytical needs later.  

```{r}
# provide unique ids for each node
node_list <- tibble(id = 1:3, description = c("gluten", "gluten free", "gluten"))
# or as matching letters
# LETTERS[1:3]
node_list
```

Alongside our unique id for each node and edge we could also include a human readable id, or instead use a unique character string or name as the id.  

For a guide on how to convert a typical dataset into an edge and node list see [Jesse Saddler's blog](https://www.jessesadler.com/post/network-analysis-with-r/).  
## A real example - Government Innovation and Emerging Technology useage

Two tidy data frames can hold our data, but why is this format useful?

The UK Government recently published
## Conclusion

 

## References

* Barbasi, A. [Network Science book](http://networksciencebook.com/).  
* Saddler, J. [Network analysis with R](https://www.jessesadler.com/post/network-analysis-with-r/).  
* Ognyanova, K. (2016) Network analysis with R and igraph: NetSci X Tutorial. Retrieved from www.kateto.net/networks-r-igraph  
* [SysMIC course](https://sysmic.ac.uk/). Section 1.1.  
* A [bunch of useful references and papers](http://networksciencebook.com/chapter/2#bibliography2).  


```{r}
devtools::session_info()
```